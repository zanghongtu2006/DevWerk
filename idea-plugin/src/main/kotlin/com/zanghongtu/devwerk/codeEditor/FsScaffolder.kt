package com.zanghongtu.devwerk.codeEditor

import com.intellij.openapi.command.WriteCommandAction
import com.intellij.openapi.project.Project
import com.intellij.openapi.vfs.LocalFileSystem
import com.intellij.openapi.vfs.VfsUtil
import com.intellij.openapi.vfs.VirtualFile
import java.io.IOException

object FsScaffolder {

    // ========== 1. ÊóßÁöÑËÑöÊâãÊû∂Êé•Âè£Ôºà‰øùÁïôÔºâ ==========

//    fun generateScaffold(project: Project, baseDir: VirtualFile, template: ScaffoldTemplate) {
//        WriteCommandAction.runWriteCommandAction(project) {
//            when (template) {
//                ScaffoldTemplate.SimpleBackend -> generateSimpleBackend(baseDir)
//                ScaffoldTemplate.SimpleFrontend -> generateSimpleFrontend(baseDir)
//                ScaffoldTemplate.EmptyModule -> generateEmptyModule(baseDir)
//            }
//        }
//    }

//    private fun generateSimpleBackend(baseDir: VirtualFile) {
//        val moduleRoot = createChildDirectory(baseDir, "backend-module")
//        val srcMainJava = createNestedDirs(moduleRoot, "src/main/java/com/example/app")
//        val srcMainResources = createNestedDirs(moduleRoot, "src/main/resources")
//        createNestedDirs(moduleRoot, "src/test/java/com/example/app")
//
//        createFileWithContent(
//            moduleRoot,
//            "build.gradle.kts",
//            """
//            plugins {
//                kotlin("jvm") version "1.9.23"
//                application
//            }
//
//            repositories {
//                mavenCentral()
//            }
//
//            dependencies {
//                testImplementation(kotlin("test"))
//            }
//
//            application {
//                mainClass.set("com.example.app.MainKt")
//            }
//            """.trimIndent()
//        )
//
//        createFileWithContent(
//            srcMainJava,
//            "Main.kt",
//            """
//            package com.example.app
//
//            fun main() {
//                println("Hello from backend scaffold!")
//            }
//            """.trimIndent()
//        )
//
//        createFileWithContent(
//            srcMainResources,
//            "application.yaml",
//            """
//            server:
//              port: 8080
//            """.trimIndent()
//        )
//
//        createFileWithContent(
//            moduleRoot,
//            "README.md",
//            "# Backend Module\n\nGenerated by DevWerk."
//        )
//    }

//    private fun generateSimpleFrontend(baseDir: VirtualFile) {
//        val moduleRoot = createChildDirectory(baseDir, "frontend-module")
//        val srcDir = createNestedDirs(moduleRoot, "src")
//        val publicDir = createNestedDirs(moduleRoot, "public")
//
//        createFileWithContent(
//            moduleRoot,
//            "package.json",
//            """
//            {
//              "name": "frontend-module",
//              "version": "0.0.1",
//              "scripts": {
//                "dev": "vite",
//                "build": "vite build",
//                "preview": "vite preview"
//              },
//              "dependencies": {},
//              "devDependencies": {}
//            }
//            """.trimIndent()
//        )
//
//        createFileWithContent(
//            srcDir,
//            "main.js",
//            """
//            document.addEventListener("DOMContentLoaded", () => {
//              const root = document.getElementById("app");
//              if (root) {
//                root.innerText = "Hello from frontend scaffold!";
//              }
//            });
//            """.trimIndent()
//        )
//
//        createFileWithContent(
//            publicDir,
//            "index.html",
//            """
//            <!DOCTYPE html>
//            <html lang="en">
//            <head>
//              <meta charset="UTF-8" />
//              <title>Frontend Scaffold</title>
//            </head>
//            <body>
//              <div id="app"></div>
//              <script type="module" src="/src/main.js"></script>
//            </body>
//            </html>
//            """.trimIndent()
//        )
//
//        createFileWithContent(
//            moduleRoot,
//            "README.md",
//            "# Frontend Module\n\nGenerated by DevWerk."
//        )
//    }
//
//    private fun generateEmptyModule(baseDir: VirtualFile) {
//        val moduleRoot = createChildDirectory(baseDir, "empty-module")
//        createFileWithContent(
//            moduleRoot,
//            "README.md",
//            "# Empty Module\n\nJust an empty scaffold to start from."
//        )
//    }
//
//    // ========== 2. ‰ªé code_tree ÊñáÊú¨ÁîüÊàêÁõÆÂΩïÔºàÂèØ‰ª•‰øùÁïôÂ§áÁî®Ôºå‰∏ç‰∏ÄÂÆöÁî®Ôºâ ==========
//
//    fun applyCodeTreeFromText(project: Project, codeTree: String) {
//        val basePath = project.basePath ?: return
//        val baseDir = LocalFileSystem.getInstance().findFileByPath(basePath) ?: return
//
//        val roots = parseCodeTree(codeTree)
//        if (roots.isEmpty()) return
//
//        WriteCommandAction.runWriteCommandAction(project) {
//            for (root in roots) {
//                createFromNode(baseDir, root)
//            }
//        }
//    }

    private data class CodeNode(
        val name: String,
        val isDir: Boolean,
        val children: MutableList<CodeNode> = mutableListOf()
    )

    private fun parseCodeTree(text: String): List<CodeNode> {
        val roots = mutableListOf<CodeNode>()
        val stack = mutableListOf<Pair<Int, CodeNode>>() // level -> node

        for (rawLine in text.lines()) {
            if (rawLine.isBlank()) continue
            val line = rawLine.rstrip()
            val trimmed = line.trimStart()
            if (trimmed.isBlank()) continue
            if (trimmed.startsWith("===")) continue

            var firstNonWs = line.indexOfFirst { !it.isWhitespace() }
            if (firstNonWs < 0) firstNonWs = 0
            val level = firstNonWs / 2

            var token = trimmed
            if (token.startsWith("üìÅ ") || token.startsWith("üìÑ ")) {
                token = token.substring(2).trimStart()
            }

            val isDir = token.endsWith("/")
            val name = if (isDir) token.removeSuffix("/") else token
            if (name.isBlank()) continue

            val node = CodeNode(name = name, isDir = isDir)

            while (stack.isNotEmpty() && stack.last().first >= level) {
                stack.removeAt(stack.size - 1)
            }

            if (stack.isEmpty()) {
                roots += node
            } else {
                stack.last().second.children += node
            }

            if (isDir) {
                stack += level to node
            }
        }

        return roots
    }

    private fun String.rstrip(): String = replace(Regex("\\s+$"), "")

    private fun createFromNode(parentDir: VirtualFile, node: CodeNode) {
        if (node.isDir) {
            val dir = createChildDirectory(parentDir, node.name)
            for (child in node.children) {
                createFromNode(dir, child)
            }
        } else {
            createFileWithContent(parentDir, node.name, "")
        }
    }

    // ========== 3. Êñ∞Â¢ûÔºöÂ∫îÁî®ÁªìÊûÑÂåñ FileOp Êåá‰ª§ ==========

    fun applyFileOps(project: Project, ops: List<FileOp>) {
        if (ops.isEmpty()) return

        val basePath = project.basePath ?: return
        val baseDir = LocalFileSystem.getInstance().findFileByPath(basePath) ?: return

        WriteCommandAction.runWriteCommandAction(project) {
            for (fileOp in ops) {
                applySingleOp(baseDir, fileOp)
            }
        }
    }

    private fun applySingleOp(baseDir: VirtualFile, op: FileOp) {
        val normalizedPath = op.path.trim().trimStart('/', '\\')
        if (normalizedPath.isEmpty()) return

        val parts = normalizedPath.split("/", "\\").filter { it.isNotBlank() }
        if (parts.isEmpty()) return

        val isDirOp = op.op == "create_dir" || op.op == "delete_dir"

        val dirPathParts: List<String>
        val fileName: String?

        if (isDirOp) {
            dirPathParts = parts
            fileName = null
        } else {
            dirPathParts = parts.dropLast(1)
            fileName = parts.last()
        }

        var current: VirtualFile = baseDir
        for (part in dirPathParts) {
            var child = current.findChild(part)
            if (child == null && op.op != "delete_dir" && op.op != "delete_file") {
                child = current.createChildDirectory(this, part)
            }
            if (child == null) {
                // Âà†Èô§Êó∂Êâæ‰∏çÂà∞Â∞±ÂΩì‰ΩúÊàêÂäüË∑≥Ëøá
                return
            }
            current = child
        }

        when (op.op) {
            "create_dir" -> {
                // ÁõÆÂΩïÂ∑≤ÁªèÈÄöËøá‰∏äÈù¢ÁöÑÂæ™ÁéØÂàõÂª∫/Ëé∑ÂèñÔºåÊó†ÈúÄÈ¢ùÂ§ñÊìç‰Ωú
            }
            "delete_dir" -> {
                if (current != baseDir) {
                    current.delete(this)
                }
            }
            "create_file", "modify_file", "update_file" -> {
                val name = fileName ?: return
                val file = current.findChild(name) ?: current.createChildData(this, name)
                val text = op.content ?: ""
                VfsUtil.saveText(file, text)
            }
            "delete_file" -> {
                val name = fileName ?: return
                val file = current.findChild(name) ?: return
                file.delete(this)
            }
            else -> {
                // Êú™Áü• opÔºöÂÖàÂøΩÁï•
            }
        }
    }

    // ========== 4. Âü∫Á°ÄÂ∑•ÂÖ∑ÊñπÊ≥ï ==========

    private fun createChildDirectory(parent: VirtualFile, name: String): VirtualFile {
        val existing = parent.findChild(name)
        if (existing != null && existing.isDirectory) return existing
        return parent.createChildDirectory(this, name)
    }

    private fun createNestedDirs(parent: VirtualFile, path: String): VirtualFile {
        var current = parent
        val parts = path.split("/", "\\").filter { it.isNotBlank() }
        for (part in parts) {
            var child = current.findChild(part)
            if (child == null) {
                child = current.createChildDirectory(this, part)
            }
            current = child
        }
        return current
    }

    private fun createFileWithContent(dir: VirtualFile, fileName: String, content: String): VirtualFile {
        val existing = dir.findChild(fileName)
        val file = existing ?: dir.createChildData(this, fileName)
        try {
            VfsUtil.saveText(file, content)
        } catch (e: IOException) {
            throw RuntimeException("Failed to write file ${file.path}: ${e.message}", e)
        }
        return file
    }
}
